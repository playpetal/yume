### This file was generated by Nexus Schema
### Do not make changes to this file directly


type Account {
  activeTitleId: Int
  bio: String
  createdAt: DateTime!
  currency: Int!
  discordId: String!
  flags: Int!
  id: Int!
  minigameStats(type: MinigameType!): MinigameStats
  premiumCurrency: Int!
  stats: AccountStats
  supporterTime: Float
  tags: [Tag!]!
  title: Title
  username: String!
}

"""Account Stats"""
type AccountStats {
  cardCount: Int!
  rollCount: Int!
}

type Alias {
  alias: String!
  group: Group!
  groupId: Int!
  id: Int!
}

type Announcement {
  announcement: String!
  createdAt: DateTime!
  id: Int!
}

type Bias {
  account: Account!
  accountId: Int!
  group: Group!
  groupId: Int!
}

type Card {
  createdAt: DateTime!
  hasFrame: Boolean!
  id: Int!
  issue: Int
  owner: Account
  ownerId: Int
  prefab: CardPrefab!
  prefabId: Int!
  quality: Quality!
  tag: Tag
  tagId: Int
  tint: Int!
}

"""Cards"""
type CardPrefab {
  character: Character!
  characterId: Int!
  group: Group
  groupId: Int
  id: Int!
  maxCards: Int!
  rarity: Int!
  release: Release!
  releaseId: Int!
  subgroup: Subgroup
  subgroupId: Int
}

"""An individual character."""
type Character {
  birthday: DateTime
  gender: Gender
  id: Int!
  name: String!
}

"""The `DateTime` custom scalar type represents a point in time."""
scalar DateTime

"""Account Flags"""
enum Flag {
  DEVELOPER
  PUBLIC_SUPPORTER
  RELEASE_MANAGER
}

"""Character gender"""
enum Gender {
  FEMALE
  MALE
  NONBINARY
}

"""Broad collections of cards typically encompassing many subgroups"""
type Group {
  aliases: [Alias!]!
  creation: DateTime
  gender: GroupGender
  id: Int!
  name: String!
}

"""Group gender"""
enum GroupGender {
  COED
  FEMALE
  MALE
}

"""Contains data for the 'Guess The Idol' minigame."""
type GuessTheIdol {
  """The account that initiated the minigame."""
  account: Account!

  """The ID of the account that initiated the minigame."""
  accountId: Int!

  """A list of characters that have already been guessed in this minigame."""
  attempts: [GuessTheIdolCharacter!]!

  """
  The ID of the Discord channel that this minigame is being played at, if applicable.
  """
  channelId: String

  """
  The solution to the minigame. Will only be returned when the minigame state is CANCELLED, FAILED, PENDING, or COMPLETED.
  """
  character: Character

  """
  The time, in milliseconds, this minigame took to complete. Will only returned when the minigame has ended.
  """
  elapsed: Int

  """The name of the group the answer will be in, if applicable."""
  group: String

  """
  The ID of the Discord guild that this minigame is being played at, if applicable.
  """
  guildId: String

  """The maximium amount of attempts that can be made in this minigame."""
  maxAttempts: Int!

  """
  The ID of the Discord message that this minigame is being played at, if applicable.
  """
  messageId: String

  """The time at which this minigame began."""
  startedAt: DateTime!

  """The state of the minigame."""
  state: MinigameState!

  """The amount of time allotted for this minigame."""
  timeLimit: Int!

  """The type of the minigame."""
  type: MinigameType!
}

"""Contains data for 'Guess The Idol' attempts."""
type GuessTheIdolCharacter {
  birthDate: MinigameComparison!
  birthday: DateTime
  gender: Gender
  isGender: Boolean!
  name: String!
  nameLength: MinigameComparison!
}

"""Contains data for the 'Guess The Song' minigame."""
type GuessTheSong {
  """The account that initiated the minigame."""
  account: Account!

  """The ID of the account that initiated the minigame."""
  accountId: Int!

  """A list of songs that have already been guessed in this minigame."""
  attempts: [MinigameSong!]!

  """
  The ID of the Discord channel that this minigame is being played at, if applicable.
  """
  channelId: String

  """
  The time, in milliseconds, this minigame took to complete. Will only returned when the minigame has ended.
  """
  elapsed: Int

  """
  The ID of the Discord guild that this minigame is being played at, if applicable.
  """
  guildId: String

  """The maximium amount of attempts that can be made in this minigame."""
  maxAttempts: Int!

  """
  The ID of the Discord message that this minigame is being played at, if applicable.
  """
  messageId: String

  """
  The solution to the minigame. Will only be returned when the minigame state is CANCELLED, FAILED, PENDING, or COMPLETED.
  """
  song: MinigameSong

  """The time at which this minigame began."""
  startedAt: DateTime!

  """The state of the minigame."""
  state: MinigameState!

  """The amount of time allotted for this minigame."""
  timeLimit: Int!

  """The type of the minigame."""
  type: MinigameType!

  """
  A Base64-encoded video of the song to guess. Will only be returned on minigame start.
  """
  video: String
}

"""Inventory ordering type"""
enum InventoryOrder {
  ASC
  DESC
}

type InventoryPage {
  cards: Int!
  max: Int!
}

"""Inventory sorting type"""
enum InventorySort {
  CHARACTER
  CODE
  GROUP
  ISSUE
  STAGE
  SUBGROUP
}

type Leaderboard {
  account: Account!
  accountId: Int!
  value: Float!
}

enum LeaderboardType {
  GUESS_THE_IDOLxCARD
  GUESS_THE_IDOLxLILY
  GUESS_THE_IDOLxPETAL
  GUESS_THE_IDOLxTIME
  GUESS_THE_SONGxCARD
  GUESS_THE_SONGxLILY
  GUESS_THE_SONGxPETAL
  GUESS_THE_SONGxTIME
  PUBLIC_SUPPORTER
}

"""Compares attempt information to the answer."""
enum MinigameComparison {
  EQUAL
  GREATER
  LESS
}

"""Contains data pertaining to rewards claimed for a minigame."""
type MinigameReward {
  """Returns the account of the minigame player."""
  account: Account!

  """If applicable, returns the card claimed from the minigame."""
  card: Card
}

"""Contains song data for the 'Guess The Song' minigame."""
type MinigameSong {
  group: String
  soloist: String
  title: String!
}

"""Represents the state of a minigame."""
enum MinigameState {
  """Set when the minigame has been cancelled by the player."""
  CANCELLED

  """
  Set when the minigame has been completed and the reward has been claimed.
  """
  COMPLETED

  """
  Set when the minigame has finished by time expiration or by reaching the attempt limit.
  """
  FAILED

  """Set when the minigame has been completed and the reward is pending."""
  PENDING

  """Set when the minigame is still being played."""
  PLAYING
}

type MinigameStats {
  account: Account!
  accountId: Int!
  totalAttempts: Int!
  totalCards: Int!
  totalCurrency: Int!
  totalGames: Int!
  totalPremiumCurrency: Int!
  totalTime: Int!
  type: MinigameType!
}

enum MinigameType {
  GTS
  GUESS_CHARACTER
  GUESS_THE_GROUP
  GUESS_THE_IDOL
  GUESS_THE_SONG
  WORDS
}

type Mutation {
  """Submits an answer to a 'Guess The Song' minigame."""
  answerGuessTheIdol(answer: String!): GuessTheIdol!

  """Submits an answer to a 'Guess The Song' minigame."""
  answerGuessTheSong(answer: String!): GuessTheSong!
  boost(count: Int!, discordId: String!): Boolean!
  burnCard(cardId: Int!): Int!
  cancelMinigame: Boolean!
  changeCardColor(cardId: Int!, color: Int!): Card!

  """Claims a reward from a `PENDING` minigame."""
  completeMinigame(reward: Reward!): MinigameReward!
  completeTransaction(token: String!): Boolean!
  createAccount(username: String!): Account!
  createAlias(alias: String!, groupId: Int!): Alias!
  createCharacter(birthday: DateTime, gender: Gender, name: String!): Character!
  createGroup(creation: DateTime, gender: GroupGender, name: String!): Group!
  createPrefab(characterId: Int!, groupId: Int, maxCards: Int, rarity: Int, releaseId: Int, subgroupId: Int): CardPrefab!
  createRelease: Release!
  createSong(groupId: Int, releaseId: Int, soloistId: Int, title: String!, url: String!): Song!
  createSubgroup(creation: DateTime, name: String!): Subgroup!
  createTag(emoji: String!, name: String!): Tag!
  createTitle(description: String, title: String!): Title!
  deleteAlias(id: Int!): Int!
  deleteCharacter(id: Int!): Int!
  deleteGroup(id: Int!): Int!
  deleteSong(songId: Int!): Int!
  deleteSubgroup(id: Int!): Int!
  deleteTag(tag: String!): Tag!
  editSong(groupId: Int, releaseId: Int, soloistId: Int, songId: Int!, title: String): Song!
  editTag(emoji: String, name: String, tag: String!): Tag!
  gift(cardIds: [Int!], lilies: Int, petals: Int, recipientId: Int!): Boolean!
  grantAllTitle(titleId: Int!): Int!
  grantTitle(accountId: Int!, titleId: Int!): TitleInventory!
  newTransaction(productId: Int!): Payment!
  revokeAllTitle(titleId: Int!): Int!
  revokeTitle(accountId: Int!, titleId: Int!): Int!
  rollCards(amount: Int!, gender: Gender): [Card!]!
  setBio(bio: String): Account!
  setFrame(cardId: Int!): Card!
  setUserTitle(id: Int!): Account!

  """Starts a new instance of the 'Guess The Song' minigame."""
  startGuessTheIdol(channelId: String, gender: Gender, group: String, guildId: String, messageId: String): GuessTheIdol!

  """Starts a new instance of the 'Guess The Song' minigame."""
  startGuessTheSong(channelId: String, gender: GroupGender, group: Int, guildId: String, messageId: String): GuessTheSong!
  tagCard(cardId: Int!, tag: String!): Card!
  toggleFlag(accountId: Int!, flag: Flag!): Account!
  togglePublicSupporter: Account!
  updateAlias(alias: String, groupId: Int, id: Int!): Alias!
  updateCharacter(birthday: DateTime, gender: Gender, id: Int!, name: String): Character!
  updateGroup(creation: DateTime, gender: GroupGender, id: Int!, name: String): Group!
  updateMinigameMessage(channelId: String!, guildId: String!, messageId: String!): Boolean!
  updatePrefab(characterId: Int, groupId: Int, maxCards: Int, prefabId: Int!, rarity: Int, releaseId: Int, subgroupId: Int): CardPrefab!
  updateRelease(droppable: Boolean, id: Int!): Release!
  updateSubgroup(creation: DateTime, id: Int!, name: String): Subgroup!
  upgradeCard(cardId: Int!, fodderCardId: Int!): Card!
}

type Payment {
  accountId: Int!
  cost: Int!
  id: Int!
  paymentId: String!
  productId: Int!
  success: Boolean!
  url: String!
}

type Product {
  available: Boolean!
  id: Int!
  name: String!
  price: Int!
  type: ProductType
}

enum ProductType {
  ALPHA_TITLE
  BETA_TITLE
  PAID_CURRENCY
  SIGMA_TITLE
}

enum Quality {
  BLOOM
  BUD
  FLOWER
  SEED
  SPROUT
}

type Query {
  aliases(alias: String, groupId: Int, id: Int): [Alias!]!
  canClaimPremiumRewards: Int!
  canClaimRewards: Int!
  getAnnouncements: [Announcement!]!
  getCard(id: Int!): Card
  getCharacter(id: Int!): Character
  getGroup(id: Int!): Group
  getGuessTheIdol: GuessTheIdol
  getGuessTheSong: GuessTheSong
  getLeaderboard(type: LeaderboardType!): [Leaderboard!]!
  getSubgroup(id: Int!): Subgroup
  getTag(tag: String!): Tag
  getUserTitle(id: Int!): TitleInventory
  inventory(character: String, group: String, order: InventoryOrder, page: Int!, sort: InventorySort, subgroup: String, tag: String, userId: Int!): [Card!]!
  inventoryPage(character: String, group: String, subgroup: String, tag: String, user: Int!): InventoryPage!
  isEmoji(emoji: String!): Boolean!
  isWordValid(word: String!): Boolean!
  lastRelease: Release
  payment(paymentId: String!): Payment
  prefab(id: Int!): CardPrefab
  products: [Product!]!
  reachedPurchaseLimit(productId: Int!): Boolean!
  release(id: Int!): Release
  searchCards(exclude: Int, maxQuality: Quality, minQuality: Quality, ownerId: Int!, prefabId: Int, search: String!): [Card!]!
  searchCharacters(birthday: DateTime, birthdayAfter: DateTime, birthdayBefore: DateTime, gender: Gender, group: String, maxLetters: Int, minLetters: Int, page: Int, search: String!): [Character!]!
  searchGroups(search: String!): [Group!]!
  searchPrefabs(search: String!): [CardPrefab!]!
  searchSubgroups(search: String!): [Subgroup!]!
  searchTags(search: String!): [Tag!]!
  searchTitles(search: String!): [Title!]!
  title(id: Int, title: String): Title
  user(discordId: String, id: Int, username: String): Account
  userTitles(accountId: Int!, search: String): [TitleInventory!]!
  word: String!
}

type Release {
  cards: [CardPrefab!]!
  droppable: Boolean!
  id: Int!
}

enum Reward {
  CARD
  LILY
  PETAL
}

type Song {
  group: Group
  groupId: Int
  id: Int!
  release: Release!
  releaseId: Int!
  soloist: Character
  soloistId: Int
  title: String!
}

"""A collection typically containing several similarly-themed cards"""
type Subgroup {
  creation: DateTime
  id: Int!
  name: String!
}

type Tag {
  account: Account!
  accountId: Int!
  cardCount: Int!
  emoji: String!
  id: Int!
  tag: String!
  updatedAt: DateTime!
}

type Title {
  description: String
  id: Int!
  inventory: [TitleInventory!]!
  ownedCount: Int!
  title: String!
}

type TitleInventory {
  account: Account!
  accountId: Int!
  id: Int!
  title: Title!
  titleId: Int!
}
